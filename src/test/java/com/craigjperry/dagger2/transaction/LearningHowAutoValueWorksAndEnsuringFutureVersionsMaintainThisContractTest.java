package com.craigjperry.dagger2.transaction;

import com.google.auto.value.AutoValue;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class LearningHowAutoValueWorksAndEnsuringFutureVersionsMaintainThisContractTest {

    private Pair<Transaction, Transaction> equal;
    private Pair<Transaction, Transaction> differing;

    @Before
    public void setUp() throws Exception {
        equal = equalTransactions();
        differing = differingTransactions();
    }

    @Test
    public void equalAutoValueObjectsAreEqual() throws Exception {
        assertThat(equal.left())
                .isEqualTo(equal.right());
    }

    @Test
    public void unequalAutoValueObjectsAreNotEqual() throws Exception {
        assertThat(differing.left())
                .isNotEqualTo(differing.right());
    }

    @Test
    public void autoValueObjectsAutoGeneratedEqualCanHandleNulls() throws Exception {
        assertThat(equal.left())
                .isNotEqualTo(null);
    }

    @Test
    public void equalAutoValueObjectsHaveMatchingToString() throws Exception {
        assertThat(equal.left().toString())
                .isEqualTo(equal.right().toString());
    }

    @Test
    public void unequalAutoValueObjectsHaveDifferingToString() throws Exception {
        assertThat(differing.left().toString())
                .isNotEqualTo(differing.right().toString());
    }

    @Test
    public void equalAutoValueObjectsHaveMatchingHashValue() throws Exception {
        assertThat(equal.left().hashCode())
                .isEqualTo(equal.right().hashCode());
    }

    @Test
    public void unequalAutoValueObjectsHaveDifferingHashValue() throws Exception {
        // The contract of hash() does not guarantee hash() is different for unequal objects
        assertThat(differing.left().hashCode())
                .isNotEqualTo(differing.right().hashCode());
    }

    @Test
    public void amountIsImplementedAutomatically() throws Exception {
        assertThat(Transaction.builder().sourceAccount(1234L).destinationAccount(4321L).amount(7L).build().amount()).isEqualTo(7);
    }

    @Test(expected = NullPointerException.class)
    public void nullParametersToAnAutoValueObjectFailFast() throws Exception {
        Pair.of(null, null);
    }

    @AutoValue
    abstract static class Pair<L, R> {
        // <L, R> re-defined since you can't reuse a class's generic type parameter in a static method
        static <L, R> Pair<L, R> of(L left, R right) {
            return new AutoValue_LearningHowAutoValueWorksAndEnsuringFutureVersionsMaintainThisContractTest_Pair<>(left, right);
        }

        abstract L left();

        abstract R right();
    }

    private Pair<Transaction, Transaction> equalTransactions() {
        return Pair.of(Transaction.builder().sourceAccount(1234L).destinationAccount(4321L).amount(1L).build(), Transaction.builder().sourceAccount(1234L).destinationAccount(4321L).amount(001L).build());
    }

    private Pair<Transaction, Transaction> differingTransactions() {
        return Pair.of(Transaction.builder().sourceAccount(1234L).destinationAccount(4321L).amount(1L).build(), Transaction.builder().sourceAccount(1234L).destinationAccount(4321L).amount(-1L).build());
    }

    // Could a malicious party mess with your immutable value types?
    static class AttackOnPair extends Pair<Integer, Integer> {
        private static Integer left;
        private static Integer right;

        AttackOnPair(Integer left, Integer right) {
            AttackOnPair.left = left;
            AttackOnPair.right = right;
        }

        static AttackOnPair of(Integer left, Integer right) {
            return new AttackOnPair(left, right);
        }

        @Override
        Integer left() {
            return left;
        }

        @Override
        Integer right() {
            return right;
        }

        void setLeft(Integer left) {
            this.left = left;
        }
    }

    @Ignore("Subclass attack is possible as demonstrated here")
    @Test
    public void referenceToImmutableValueTypeChangesUnexpectedly() throws Exception {
        Pair<Integer, Integer> immutablePairReference = AttackOnPair.of(1, 1);
        assertThat(1).isEqualTo(immutablePairReference.left());
        ((AttackOnPair) immutablePairReference).setLeft(2);
        assertThat(1).isEqualTo(immutablePairReference.left());
    }
}
